package Buddy.plugin.trackmate.visualization.hyperstack;

import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.ComponentEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Set;

import javax.swing.SwingUtilities;

import org.jgrapht.graph.DefaultWeightedEdge;

import Buddy.plugin.trackmate.Logger;
import Buddy.plugin.trackmate.Model;
import Buddy.plugin.trackmate.SelectionModel;
import Buddy.plugin.trackmate.BCellobjectCollection;
import Buddy.plugin.trackmate.util.TMUtils;
import budDetector.BCellobject;
import fiji.tool.AbstractTool;
import fiji.tool.ToolWithOptions;
import ij.IJ;
import ij.ImagePlus;
import ij.gui.FreehandRoi;
import ij.gui.ImageCanvas;
import ij.gui.Toolbar;

public class BCellobjectEditTool extends AbstractTool implements MouseMotionListener, MouseListener, MouseWheelListener, KeyListener, ToolWithOptions
{

	private static final boolean DEBUG = false;

	private static final double COARSE_STEP = 2;

	private static final double FINE_STEP = 0.2f;

	private static final String TOOL_NAME = "BCellobject edit tool";

	private static final String TOOL_ICON = "CeacD70Cd8bD80"
			+ "D71Cc69D81CfefD91"
			+ "CdbcD72Cb9bD82"
			+ "Cd9bD73Cc8aD83CfefD93"
			+ "CdddD54CbaaD64Cb69D74Cb59D84Cb9aD94CdddDa4"
			+ "CfefD25Cd9bD35Cb8aD45CaaaD55CcccD65CfdeL7585CdccD95CaaaDa5Cb8aDb5Cd7aDc5CfceDd5"
			+ "CfeeD26Cc69D36Cc8aD46CdacDb6Cb59Dc6CecdDd6"
			+ "Cb9aD37CdcdD47CeeeDb7Ca89Dc7"
			+ "CfefD28Cc7aD38Cd9cD48CecdDb8Cb79Dc8CfdeDd8"
			+ "CcabD29Cb59D39Cb69D49CedeD59CeacDb9Cc59Dc9CebdDd9"
			+ "CfdeD0aCc7aD1aCb8aD2aCedeD3aCcbcD4aCb7aD5aCe9cD6aCeeeDbaCa89DcaCfefDda"
			+ "CebdD0bCc59D1bCebdD2bCfefD4bCc7aL5b6bCeceDbbCb79DcbCfdeDdb"
			+ "CfeeD0cCa89D1cCfefD2cCcabL5c6cCc9bDbcCc59DccCdabDdc"
			+ "CedeD0dCb79D1dCedeD2dCc9bL5d6dCecdD9dCc8aDadCb9aDbdCdbcDcdCb8aDddCd8bDedCfceDfd"
			+ "CebdD0eCc59D1eCebdD2eCfeeD4eCc7aD5eCc6aD6eCfeeD7eCd9bD9eCc59DaeCfdeDbeCebdDdeCc59DeeCeacDfe"
			+ "CfefD0fCdbcD1fCdddD4fCdcdL5f6fCdddD7fCfdeD9fCdbdDafCebdDefCfefDff";

	/**
	 * Fall back default radius when the settings does not give a default radius
	 * to use.
	 */
	private static final double FALL_BACK_RADIUS = 5.;

	/** The singleton instance. */
	private static BCellobjectEditTool instance;

	/** Stores the edited BCellobject in each {@link ImagePlus}. */
	private final HashMap< ImagePlus, BCellobject > editedBCellobjects = new HashMap<>();

	/** Stores the view possible attached to each {@link ImagePlus}. */
	HashMap< ImagePlus, HyperStackDisplayer > displayers = new HashMap<>();

	/** The radius of the previously edited BCellobject. */
	private Double previousRadius = null;

	private BCellobject quickEditedBCellobject;

	/** Flag for the auto-linking mode. */
	private boolean autolinkingmode = false;

	BCellobjectEditToolParams params = new BCellobjectEditToolParams();

	private Logger logger = Logger.IJTOOLBAR_LOGGER;

	private BCellobjectEditToolConfigPanel configPanel;

	/**
	 * The last {@link ImagePlus} on which an action happened.
	 */
	ImagePlus imp;

	private FreehandRoi roiedit;

	/*
	 * CONSTRUCTOR
	 */

	/**
	 * Singleton
	 */
	private BCellobjectEditTool()
	{}

	/**
	 * Return the singleton instance for this tool. If it was not previously
	 * instantiated, this calls instantiates it.
	 */
	public static BCellobjectEditTool getInstance()
	{
		if ( null == instance )
		{
			instance = new BCellobjectEditTool();
			if ( DEBUG )
				System.out.println( "[BCellobjectEditTool] Instantiating: " + instance );
		}
		if ( DEBUG )
			System.out.println( "[BCellobjectEditTool] Returning instance: " + instance );
		return instance;
	}

	/**
	 * Return true if the tool is currently present in ImageJ toolbar.
	 */
	public static boolean isLaunched()
	{
		final Toolbar toolbar = Toolbar.getInstance();
		if ( null != toolbar && toolbar.getToolId( TOOL_NAME ) >= 0 )
			return true;
		return false;
	}

	/*
	 * METHODS
	 */

	@Override
	public String getToolName()
	{
		return TOOL_NAME;
	}

	@Override
	public String getToolIcon()
	{
		return TOOL_ICON;
	}

	/**
	 * Overridden so that we can keep track of the last ImagePlus actions are
	 * taken on. Very much like ImageJ.
	 */
	@Override
	public ImagePlus getImagePlus( final ComponentEvent e )
	{
		imp = super.getImagePlus( e );
		return imp;
	}

	/**
	 * Register the given {@link HyperStackDisplayer}. If this method id not
	 * called, the tool will not respond.
	 */
	public void register( final ImagePlus lImp, final HyperStackDisplayer displayer )
	{
		if ( DEBUG )
			System.out.println( "[BCellobjectEditTool] Currently registered: " + displayers );

		if ( displayers.containsKey( lImp ) )
		{
			unregisterTool( lImp );
			if ( DEBUG )
				System.out.println( "[BCellobjectEditTool] De-registering " + lImp + " as tool listener." );
		}

		displayers.put( lImp, displayer );
		if ( DEBUG )
		{
			System.out.println( "[BCellobjectEditTool] Registering " + lImp + " and " + displayer + "." + " Currently registered: " + displayers );
		}
	}

	/*
	 * MOUSE AND MOUSE MOTION
	 */

	@Override
	public void mouseClicked( final MouseEvent e )
	{
		final ImagePlus lImp = getImagePlus( e );
		final HyperStackDisplayer displayer = displayers.get( lImp );
		if ( DEBUG )
		{
			System.out.println( "[BCellobjectEditTool] @mouseClicked" );
			System.out.println( "[BCellobjectEditTool] Got " + lImp + " as ImagePlus" );
			System.out.println( "[BCellobjectEditTool] Matching displayer: " + displayer );

			for ( final MouseListener ml : lImp.getCanvas().getMouseListeners() )
				System.out.println( "[BCellobjectEditTool] mouse listener: " + ml );
		}

		if ( null == displayer )
			return;

		final BCellobject clickLocation = makeBCellobject( lImp, displayer, getImageCanvas( e ), e.getPoint() );
		final int frame = displayer.imp.getFrame() - 1;
		final Model model = displayer.getModel();
		BCellobject target = model.getBCellobjects().getBCellobjectAt( clickLocation, frame, true );
		BCellobject editedBCellobject = editedBCellobjects.get( lImp );

		final SelectionModel selectionModel = displayer.getSelectionModel();

		// Check desired behavior
		switch ( e.getClickCount() )
		{

		case 1:
		{
			// Change selection
			// only if we are not currently editing.
			if ( null != editedBCellobject )
			{ return; }
			// If no target, we clear selection
			if ( null == target )
			{
				if ( !autolinkingmode )
				{
					selectionModel.clearSelection();
					logger.log( "Cleared selection.\n" );
				}
				roiedit = null;
				lImp.setRoi( roiedit );
			}
			else
			{

				updateStatusBar( target, lImp.getCalibration().getUnits() );
				final int addToSelectionMask = InputEvent.SHIFT_DOWN_MASK;
				if ( ( e.getModifiersEx() & addToSelectionMask ) == addToSelectionMask )
				{
					if ( selectionModel.getBCellobjectSelection().contains( target ) )
						selectionModel.removeBCellobjectFromSelection( target );
					else
						selectionModel.addBCellobjectToSelection( target );
				}
				else
				{
					selectionModel.clearBCellobjectSelection();
					selectionModel.addBCellobjectToSelection( target );
				}
			}
			break;
		}

		case 2:
		{
			// Edit BCellobject

			if ( null == editedBCellobject )
			{
				// No BCellobject is currently edited, we pick one to edit
				Double radius;
				if ( null != target && null != target.getFeature( BCellobject.RADIUS ) )
				{
					radius = target.getFeature( BCellobject.RADIUS );
					logger.log( "Editing BCellobject " + target + ".\n" );
				}
				else
				{
					radius = previousRadius;
					if ( null == radius )
						radius = FALL_BACK_RADIUS;
				}
				if ( null == target || target.squareDistanceTo( clickLocation ) > radius * radius )
				{
					// Create a new BCellobject if not inside one
					target = clickLocation;
					if ( null == previousRadius )
						previousRadius = radius;

					target.putFeature( BCellobject.RADIUS, previousRadius );
					logger.log( "Creating new BCellobject.\n" );

				}
				editedBCellobject = target;
				displayer.BCellobjectOverlay.editingBCellobject = editedBCellobject;
				displayer.refresh();
				// Edit BCellobject
				if ( DEBUG )
					System.out.println( "[BCellobjectEditTool] mouseClicked: Set " + editedBCellobject + " as editing BCellobject for this imp." );

			}
			else
			{
				// We leave editing mode
				if ( DEBUG )
					System.out.println( "[BCellobjectEditTool] mouseClicked: Got " + editedBCellobject + " as editing BCellobject for this imp, leaving editing mode." );

				/*
				 * A hack: we update the current z and t of the edited BCellobject to
				 * the current one, because it is not updated otherwise: there
				 * is no way to listen to slice change
				 */
				final double calibration[] = TMUtils.getSpatialCalibration( lImp );
				final double zslice = ( displayer.imp.getSlice() - 1 ) * calibration[ 2 ];
				editedBCellobject.putFeature( BCellobject.POSITION_Z, zslice );
				final Double initFrame = editedBCellobject.getFeature( BCellobject.FRAME );
				// Move it in Z
				final double z = ( displayer.imp.getSlice() - 1 ) * calibration[ 2 ];
				editedBCellobject.putFeature( BCellobject.POSITION_Z, z );
				editedBCellobject.putFeature( BCellobject.POSITION_T, frame * lImp.getCalibration().frameInterval );
				editedBCellobject.putFeature( BCellobject.FRAME, Double.valueOf( frame ) );

				model.beginUpdate();
				try
				{
					if ( initFrame == null )
					{
						// Means that the BCellobject was created
						model.addBCellobjectTo( editedBCellobject, frame );
					}
					else if ( initFrame != frame )
					{
						// Move it to the new frame
						model.moveBCellobjectFrom( editedBCellobject, initFrame.intValue(), frame );
					}
					else
					{
						// The BCellobjects pre-existed and was not moved across frames
						model.updateFeatures( editedBCellobject );
					}
					logger.log( "Finished editing BCellobject " + editedBCellobject + ".\n" );

				}
				finally
				{
					model.endUpdate();
				}

				/*
				 * If we are in auto-link mode, we create an edge with BCellobject in
				 * selection, if there is just one and if it is in a previous
				 * frame
				 */
				if ( autolinkingmode )
				{
					final Set< BCellobject > BCellobjectSelection = selectionModel.getBCellobjectSelection();
					if ( BCellobjectSelection.size() == 1 )
					{
						final BCellobject source = BCellobjectSelection.iterator().next();
						if ( editedBCellobject.diffTo( source, BCellobject.FRAME ) > 0 )
						{
							model.beginUpdate();
							try
							{
								model.addEdge( source, editedBCellobject, -1 );
								logger.log( "Created a link between " + source + " and " + editedBCellobject + ".\n" );
							}
							finally
							{
								model.endUpdate();
							}
						}
					}
				}

				// Set selection
				selectionModel.clearBCellobjectSelection();
				selectionModel.addBCellobjectToSelection( editedBCellobject );

				// Forget edited BCellobject, but remember its radius
				previousRadius = editedBCellobject.getFeature( BCellobject.RADIUS );
				editedBCellobject = null;
				displayer.BCellobjectOverlay.editingBCellobject = null;
			}
			break;
		}
		}
		editedBCellobjects.put( lImp, editedBCellobject );
	}

	@Override
	public void mousePressed( final MouseEvent e )
	{}

	@Override
	public void mouseReleased( final MouseEvent e )
	{
		if ( null != roiedit )
		{
			new Thread( "BCellobjectEditTool roiedit processing" )
			{
				@Override
				public void run()
				{
					roiedit.mouseReleased( e );
					final ImagePlus lImp = getImagePlus( e );
					final HyperStackDisplayer displayer = displayers.get( lImp );
					final int frame = displayer.imp.getFrame() - 1;
					final Model model = displayer.getModel();
					final SelectionModel selectionModel = displayer.getSelectionModel();

					final Iterator< BCellobject > it;
					if ( IJ.shiftKeyDown() )
						it = model.getBCellobjects().iterator( true );
					else
						it = model.getBCellobjects().iterator( frame, true );

					final Collection< BCellobject > added = new ArrayList<>();
					final double calibration[] = TMUtils.getSpatialCalibration( lImp );

					while ( it.hasNext() )
					{
						final BCellobject BCellobject = it.next();
						final double x = BCellobject.getFeature( BCellobject.POSITION_X );
						final double y = BCellobject.getFeature( BCellobject.POSITION_Y );
						// In pixel units
						final int xp = ( int ) ( x / calibration[ 0 ] + 0.5f );
						final int yp = ( int ) ( y / calibration[ 1 ] + 0.5f );

						if ( null != roiedit && roiedit.contains( xp, yp ) )
							added.add( BCellobject );
					}

					if ( !added.isEmpty() )
					{
						selectionModel.addBCellobjectToSelection( added );
						if ( added.size() == 1 )
							logger.log( "Added one BCellobject to selection.\n" );
						else
							logger.log( "Added " + added.size() + " BCellobjects to selection.\n" );
					}
					roiedit = null;
				}
			}.start();
		}
	}

	@Override
	public void mouseEntered( final MouseEvent e )
	{}

	@Override
	public void mouseExited( final MouseEvent e )
	{}

	@Override
	public void mouseDragged( final MouseEvent e )
	{
		final ImagePlus lImp = getImagePlus( e );
		final double[] calibration = TMUtils.getSpatialCalibration( lImp );
		final HyperStackDisplayer displayer = displayers.get( lImp );
		if ( null == displayer )
			return;
		final BCellobject editedBCellobject = editedBCellobjects.get( lImp );
		if ( null != editedBCellobject )
		{
			final Point mouseLocation = e.getPoint();
			final ImageCanvas canvas = getImageCanvas( e );
			final double x = ( -0.5 + canvas.offScreenXD( mouseLocation.x ) ) * calibration[ 0 ];
			final double y = ( -0.5 + canvas.offScreenYD( mouseLocation.y ) ) * calibration[ 1 ];
			final double z = ( lImp.getSlice() - 1 ) * calibration[ 2 ];
			editedBCellobject.putFeature( BCellobject.POSITION_X, x );
			editedBCellobject.putFeature( BCellobject.POSITION_Y, y );
			editedBCellobject.putFeature( BCellobject.POSITION_Z, z );
			displayer.imp.updateAndDraw();
			updateStatusBar( editedBCellobject, lImp.getCalibration().getUnits() );
		}
		else
		{
			if ( null == roiedit )
			{
				if ( !IJ.spaceBarDown() )
				{
					roiedit = new FreehandRoi( e.getX(), e.getY(), lImp )
					{
						private static final long serialVersionUID = 1L;

						@Override
						protected void handleMouseUp( final int screenX, final int screenY )
						{
							type = FREEROI;
							super.handleMouseUp( screenX, screenY );
						}
					};
					lImp.setRoi( roiedit );
				}
			}
			else
			{
				roiedit.mouseDragged( e );
			}
		}
	}

	@Override
	public void mouseMoved( final MouseEvent e )
	{
		if ( quickEditedBCellobject == null )
			return;
		final ImagePlus lImp = getImagePlus( e );
		final double[] calibration = TMUtils.getSpatialCalibration( lImp );
		final HyperStackDisplayer displayer = displayers.get( lImp );
		if ( null == displayer )
			return;
		final BCellobject editedBCellobject = editedBCellobjects.get( lImp );
		if ( null != editedBCellobject )
			return;

		final Point mouseLocation = e.getPoint();
		final ImageCanvas canvas = getImageCanvas( e );
		final double x = ( -0.5 + canvas.offScreenXD( mouseLocation.x ) ) * calibration[ 0 ];
		final double y = ( -0.5 + canvas.offScreenYD( mouseLocation.y ) ) * calibration[ 1 ];
		final double z = ( lImp.getSlice() - 1 ) * calibration[ 2 ];

		quickEditedBCellobject.putFeature( BCellobject.POSITION_X, x );
		quickEditedBCellobject.putFeature( BCellobject.POSITION_Y, y );
		quickEditedBCellobject.putFeature( BCellobject.POSITION_Z, z );
		displayer.imp.updateAndDraw();

	}

	/*
	 * MOUSEWHEEL
	 */

	@Override
	public void mouseWheelMoved( final MouseWheelEvent e )
	{
		final ImagePlus lImp = getImagePlus( e );
		final HyperStackDisplayer displayer = displayers.get( lImp );
		if ( null == displayer )
			return;
		final BCellobject editedBCellobject = editedBCellobjects.get( lImp );
		if ( null == editedBCellobject || !e.isAltDown() )
			return;
		double radius = editedBCellobject.getFeature( BCellobject.RADIUS );
		final double dx = lImp.getCalibration().pixelWidth;
		if ( e.isShiftDown() )
			radius += e.getWheelRotation() * dx * COARSE_STEP;
		else
			radius += e.getWheelRotation() * dx * FINE_STEP;

		if ( radius < dx )
		{
			e.consume();
			return;
		}

		editedBCellobject.putFeature( BCellobject.RADIUS, radius );
		displayer.imp.updateAndDraw();
		e.consume();
		updateStatusBar( editedBCellobject, lImp.getCalibration().getUnits() );
	}

	/*
	 * KEYLISTENER
	 */

	@Override
	public void keyTyped( final KeyEvent e )
	{}

	@Override
	public void keyPressed( final KeyEvent e )
	{

		if ( DEBUG )
			System.out.println( "[BCellobjectEditTool] keyPressed: " + e.getKeyChar() );

		final ImagePlus lImp = getImagePlus( e );
		if ( lImp == null )
			return;
		final HyperStackDisplayer displayer = displayers.get( lImp );
		if ( null == displayer )
			return;

		final Model model = displayer.getModel();
		final SelectionModel selectionModel = displayer.getSelectionModel();
		BCellobject editedBCellobject = editedBCellobjects.get( lImp );
		final ImageCanvas canvas = getImageCanvas( e );

		final int keycode = e.getKeyCode();

		switch ( keycode )
		{

		// Delete currently edited BCellobject
		case KeyEvent.VK_DELETE:
		{
			if ( null == editedBCellobject )
			{
				final ArrayList< BCellobject > BCellobjectSelection = new ArrayList<>( selectionModel.getBCellobjectSelection() );
				final ArrayList< DefaultWeightedEdge > edgeSelection = new ArrayList<>( selectionModel.getEdgeSelection() );
				model.beginUpdate();
				try
				{
					selectionModel.clearSelection();
					for ( final DefaultWeightedEdge edge : edgeSelection )
					{
						model.removeEdge( edge );
						logger.log( "Removed edge " + edge + ".\n" );
					}
					for ( final BCellobject BCellobject : BCellobjectSelection )
					{
						model.removeBCellobject( BCellobject );
						logger.log( "Removed BCellobject " + BCellobject + ".\n" );
					}
				}
				finally
				{
					model.endUpdate();
				}

			}
			else
			{
				model.beginUpdate();
				try
				{
					model.removeBCellobject( editedBCellobject );
					logger.log( "Removed " + editedBCellobject + ".\n" );
				}
				finally
				{
					model.endUpdate();
				}
				editedBCellobject = null;
				editedBCellobjects.put( lImp, null );
			}
			lImp.updateAndDraw();
			e.consume();
			break;
		}

		// Quick add BCellobject at mouse
		case KeyEvent.VK_A:
		{

			if ( null == editedBCellobject )
			{

				if ( e.isShiftDown() )
				{
					logger.log( "Semi-automatic tracking.\n" );
					// Semi-auto tracking
					semiAutoTracking( model, selectionModel, lImp );

				}
				else
				{

					// Create and drop a new BCellobject
					final double radius = ( null != previousRadius )
							? previousRadius
							: FALL_BACK_RADIUS;

					final BCellobject newBCellobject = makeBCellobject( lImp, displayer, canvas, null );
					final double dt = lImp.getCalibration().frameInterval;
					final int frame = displayer.imp.getFrame() - 1;
					newBCellobject.putFeature( BCellobject.POSITION_T, frame * dt );
					newBCellobject.putFeature( BCellobject.FRAME, Double.valueOf( frame ) );
					newBCellobject.putFeature( BCellobject.RADIUS, radius );
					newBCellobject.putFeature( BCellobject.QUALITY, -1d );

					model.beginUpdate();
					try
					{
						model.addBCellobjectTo( newBCellobject, frame );
						logger.log( "Added BCellobject " + newBCellobject + " to frame " + frame + ".\n" );
					}
					finally
					{
						model.endUpdate();
					}

					/*
					 * If we are in auto-link mode, we create an edge with BCellobject
					 * in selection, if there is just one and if it is in a
					 * previous frame
					 */
					if ( autolinkingmode )
					{
						final Set< BCellobject > BCellobjectSelection = selectionModel.getBCellobjectSelection();
						if ( BCellobjectSelection.size() == 1 )
						{
							final BCellobject source = BCellobjectSelection.iterator().next();
							if ( newBCellobject.diffTo( source, BCellobject.FRAME ) != 0 )
							{
								model.beginUpdate();
								try
								{
									model.addEdge( source, newBCellobject, -1 );
									logger.log( "Created a link between " + source + " and " + newBCellobject + ".\n" );
								}
								finally
								{
									model.endUpdate();
								}
							}
						}
						selectionModel.clearBCellobjectSelection();
						selectionModel.addBCellobjectToSelection( newBCellobject );
					}

					lImp.updateAndDraw();
					e.consume();
				}

			}
			else
			{

			}
			break;
		}

		// Quick delete BCellobject under mouse
		case KeyEvent.VK_D:
		{

			if ( null == editedBCellobject )
			{

				final int frame = displayer.imp.getFrame() - 1;
				final BCellobject clickLocation = makeBCellobject( lImp, displayer, canvas, null );
				final BCellobject target = model.getBCellobjects().getBCellobjectAt( clickLocation, frame, true );
				if ( null == target )
				{
					// Consume it anyway, so that we are not bothered by IJ
					e.consume();
					return;
				}

				selectionModel.removeBCellobjectFromSelection( target );
				model.beginUpdate();
				try
				{
					model.removeBCellobject( target );
					logger.log( "Removed BCellobject " + target + ".\n" );
				}
				finally
				{
					model.endUpdate();
				}

				lImp.updateAndDraw();

			}
			else
			{

			}
			e.consume();
			break;
		}

		// Quick move BCellobject under the mouse
		case KeyEvent.VK_SPACE:
		{

			if ( null == quickEditedBCellobject )
			{
				final int frame = displayer.imp.getFrame() - 1;
				final BCellobject clickLocation = makeBCellobject( lImp, displayer, canvas, null );
				quickEditedBCellobject = model.getBCellobjects().getBCellobjectAt( clickLocation, frame, true );
				if ( null == quickEditedBCellobject )
					return;
			}
			e.consume();
			break;

		}

		// Quick change BCellobject radius
		case KeyEvent.VK_Q:
		case KeyEvent.VK_E:
		{

			e.consume();
			if ( null == editedBCellobject )
			{

				final int frame = displayer.imp.getFrame() - 1;
				final BCellobject clickLocation = makeBCellobject( lImp, displayer, canvas, null );
				final BCellobject target = model.getBCellobjects().getBCellobjectAt( clickLocation, frame, true );
				if ( null == target )
					return;

				final double radius = target.getFeature( BCellobject.RADIUS );
				final int factor = ( e.getKeyCode() == KeyEvent.VK_Q ) ? -1 : 1;
				final double dx = lImp.getCalibration().pixelWidth;

				final double newRadius = ( e.isShiftDown() )
						? radius + factor * dx * COARSE_STEP
						: radius + factor * dx * FINE_STEP;

				if ( newRadius <= dx )
					return;

				final BCellobjectRoi roi = target.getRoi();
				if ( null == roi )
				{
					target.putFeature( BCellobject.RADIUS, newRadius );
				}
				else
				{
					final double alpha = newRadius / radius;
					roi.scale( alpha );
					target.putFeature( BCellobject.RADIUS, roi.radius() );
				}

				model.beginUpdate();
				try
				{
					model.updateFeatures( target );
					logger.log( String.format( Locale.US, "Changed BCellobject " + target + " radius to %.1f " + model.getSpaceUnits() + ".\n", radius ) );
				}
				finally
				{
					model.endUpdate();
				}

				lImp.updateAndDraw();
			}

			break;
		}

		// Copy BCellobjects from previous frame
		case KeyEvent.VK_V:
		{
			if ( e.isShiftDown() )
			{

				final int currentFrame = lImp.getFrame() - 1;
				if ( currentFrame > 0 )
				{

					final BCellobjectCollection BCellobjects = model.getBCellobjects();
					if ( BCellobjects.getNBCellobjects( currentFrame - 1, true ) == 0 )
					{
						e.consume();
						break;
					}
					final HashSet< BCellobject > copiedBCellobjects = new HashSet<>( BCellobjects.getNBCellobjects( currentFrame - 1, true ) );
					final HashSet< String > featuresKey = new HashSet<>( BCellobjects.iterator( currentFrame - 1, true ).next().getFeatures().keySet() );
					// Deal with time separately
					featuresKey.remove( BCellobject.POSITION_T );
					double dt = lImp.getCalibration().frameInterval;
					if ( dt == 0. )
						dt = 1.;

					for ( final Iterator< BCellobject > it = BCellobjects.iterator( currentFrame - 1, true ); it.hasNext(); )
					{
						final BCellobject BCellobject = it.next();
						final BCellobject newBCellobject = new BCellobject( BCellobject );
						// Deal with features
						for ( final String key : featuresKey )
						{
							final Double val = BCellobject.getFeature( key );
							if ( val == null )
								continue;

							newBCellobject.putFeature( key, val );
						}
						newBCellobject.putFeature( BCellobject.POSITION_T, BCellobject.getFeature( BCellobject.POSITION_T ) + dt );
						copiedBCellobjects.add( newBCellobject );
					}

					model.beginUpdate();
					try
					{
						// Remove old ones
						final HashSet< BCellobject > toRemove = new HashSet<>();
						for ( final Iterator< BCellobject > it = BCellobjects.iterator( currentFrame, true ); it.hasNext(); )
							toRemove.add( it.next() );

						for ( final BCellobject BCellobject : toRemove )
							model.removeBCellobject( BCellobject );

						// Add new ones
						for ( final BCellobject BCellobject : copiedBCellobjects )
							model.addBCellobjectTo( BCellobject, currentFrame );
					}
					finally
					{
						model.endUpdate();
						lImp.updateAndDraw();
						logger.log( "Removed BCellobjects of frame " + currentFrame + ".\n" );
						logger.log( "Copied BCellobjects of frame " + ( currentFrame - 1 ) + " to frame " + currentFrame + ".\n" );
					}
				}

				e.consume();
			}
			break;
		}

		case KeyEvent.VK_L:
		{

			if ( e.isShiftDown() )
			{
				/*
				 * Toggle auto-linking mode
				 */
				autolinkingmode = !autolinkingmode;
				logger.log( "Toggled auto-linking mode " + ( autolinkingmode ? "on.\n" : "off.\n" ) );

			}
			else
			{
				/*
				 * Toggle a link between two BCellobjects.
				 */
				final Set< BCellobject > selectedBCellobjects = selectionModel.getBCellobjectSelection();
				if ( selectedBCellobjects.size() == 2 )
				{
					final Iterator< BCellobject > it = selectedBCellobjects.iterator();
					final BCellobject sourceTmp = it.next();
					final BCellobject targetTmp = it.next();

					final BCellobject source = sourceTmp.diffTo( targetTmp, BCellobject.FRAME ) < 0 ? sourceTmp : targetTmp;
					final BCellobject target = sourceTmp.diffTo( targetTmp, BCellobject.FRAME ) < 0 ? targetTmp : sourceTmp;

					if ( model.getTrackModel().containsEdge( source, target ) )
					{
						/*
						 * Remove it
						 */
						model.beginUpdate();
						try
						{
							model.removeEdge( source, target );
							logger.log( "Removed edge between " + source + " and " + target + ".\n" );
						}
						finally
						{
							model.endUpdate();
						}

					}
					else
					{
						/*
						 * Create a new link
						 */
						final int ts = source.getFeature( BCellobject.FRAME ).intValue();
						final int tt = target.getFeature( BCellobject.FRAME ).intValue();

						if ( tt != ts )
						{
							model.beginUpdate();
							try
							{
								model.addEdge( source, target, -1 );
								logger.log( "Created an edge between " + source + " and " + target + ".\n" );
							}
							finally
							{
								model.endUpdate();
							}
							/*
							 * To emulate a kind of automatic linking, we put
							 * the last BCellobject to the selection, so several BCellobjects
							 * can be tracked in a row without having to
							 * de-select one
							 */
							final BCellobject single = ( tt > ts ) ? target : source;
							selectionModel.clearBCellobjectSelection();
							selectionModel.addBCellobjectToSelection( single );
						}
						else
						{
							logger.error( "Cannot create an edge between two BCellobjects belonging to the same frame.\n" );
						}
					}

				}
				else
				{
					logger.error( "Expected selection to contain 2 BCellobjects, found " + selectedBCellobjects.size() + ".\n" );
				}

			}
			e.consume();
			break;

		}

		case KeyEvent.VK_G:
		case KeyEvent.VK_F:
		{
			// Stepwise time browsing.
			final int currentT = lImp.getT() - 1;
			final int prevStep = ( currentT / params.stepwiseTimeBrowsing ) * params.stepwiseTimeBrowsing;
			int tp;
			if ( keycode == KeyEvent.VK_G )
			{
				tp = prevStep + params.stepwiseTimeBrowsing;
			}
			else
			{
				if ( currentT == prevStep )
					tp = currentT - params.stepwiseTimeBrowsing;
				else
					tp = prevStep;
			}
			lImp.setT( tp + 1 );

			e.consume();
			break;
		}

		case KeyEvent.VK_W:
		{
			e.consume(); // consume it: we do not want IJ to close the window
			break;
		}

		}

	}

	private BCellobject makeBCellobject( final ImagePlus lImp, HyperStackDisplayer displayer, final ImageCanvas canvas, Point mouseLocation )
	{
		if ( displayer == null )
		{
			displayer = displayers.get( lImp );
		}
		if ( mouseLocation == null )
		{
			mouseLocation = MouseInfo.getPointerInfo().getLocation();
			SwingUtilities.convertPointFromScreen( mouseLocation, canvas );
		}
		final double[] calibration = TMUtils.getSpatialCalibration( lImp );
		return new BCellobject(
				( -0.5d + canvas.offScreenXD( mouseLocation.x ) ) * calibration[ 0 ],
				( -0.5d + canvas.offScreenYD( mouseLocation.y ) ) * calibration[ 1 ],
				( lImp.getSlice() - 1 ) * calibration[ 2 ],
				FALL_BACK_RADIUS,
				-1d );
	}

	@Override
	public void keyReleased( final KeyEvent e )
	{
		if ( DEBUG )
			System.out.println( "[BCellobjectEditTool] keyReleased: " + e.getKeyChar() );

		switch ( e.getKeyCode() )
		{
		case KeyEvent.VK_SPACE:
		{
			if ( null == quickEditedBCellobject )
				return;
			final ImagePlus lImp = getImagePlus( e );
			if ( lImp == null )
				return;
			final HyperStackDisplayer displayer = displayers.get( lImp );
			if ( null == displayer )
				return;
			final Model model = displayer.getModel();
			model.beginUpdate();
			try
			{
				model.updateFeatures( quickEditedBCellobject );
			}
			finally
			{
				model.endUpdate();
			}
			quickEditedBCellobject = null;
			break;
		}
		}

	}

	/*
	 * PRIVATE METHODS
	 */

	private void updateStatusBar( final BCellobject BCellobject, final String units )
	{
		if ( null == BCellobject )
			return;
		String statusString = "";
		if ( null == BCellobject.getName() || BCellobject.getName().equals( "" ) )
			statusString = String.format( Locale.US, "BCellobject ID%d, x = %.1f, y = %.1f, z = %.1f, r = %.1f %s", BCellobject.ID(), BCellobject.getFeature( BCellobject.POSITION_X ), BCellobject.getFeature( BCellobject.POSITION_Y ), BCellobject.getFeature( BCellobject.POSITION_Z ), BCellobject.getFeature( BCellobject.RADIUS ), units );
		else
			statusString = String.format( Locale.US, "BCellobject %s, x = %.1f, y = %.1f, z = %.1f, r = %.1f %s", BCellobject.getName(), BCellobject.getFeature( BCellobject.POSITION_X ), BCellobject.getFeature( BCellobject.POSITION_Y ), BCellobject.getFeature( BCellobject.POSITION_Z ), BCellobject.getFeature( BCellobject.RADIUS ), units );
		IJ.showStatus( statusString );
	}

	void semiAutoTracking( final Model model, final SelectionModel selectionModel, final ImagePlus lImp )
	{
		@SuppressWarnings( "rawtypes" )
		final SemiAutoTracker autotracker = new SemiAutoTracker( model, selectionModel, lImp, logger );
		autotracker.setParameters( params.qualityThreshold, params.distanceTolerance, params.nFrames );
		autotracker.setNumThreads( 4 );
		new Thread( "TrackMate semi-automated tracking thread" )
		{
			@Override
			public void run()
			{
				final boolean ok = autotracker.checkInput() && autotracker.process();
				if ( !ok )
					logger.error( autotracker.getErrorMessage() );
			}
		}.start();
	}

	@Override
	public void showOptionDialog()
	{
		if ( null == configPanel )
		{
			configPanel = new BCellobjectEditToolConfigPanel( this );
			configPanel.addWindowListener( new WindowAdapter()
			{
				@Override
				public void windowClosing( final WindowEvent e )
				{
					logger = Logger.IJTOOLBAR_LOGGER;
				}
			} );
		}
		configPanel.setLocation( toolbar.getLocationOnScreen() );
		configPanel.setVisible( true );
		logger = configPanel.getLogger();
	}

	/**
	 * Sets the radius to use for the next created BCellobject.
	 * 
	 * @param radius
	 *            the radius to use.
	 */
	public void setRadius( final double radius )
	{
		this.previousRadius = radius;
	}

	/*
	 * INNER CLASSES
	 */

	static class BCellobjectEditToolParams
	{

		/*
		 * Semi-auto tracking parameters
		 */
		/**
		 * The fraction of the initial quality above which we keep new BCellobjects.
		 * The highest, the more intolerant.
		 */
		double qualityThreshold = 0.5;

		/**
		 * How close must be the new BCellobject found to be accepted, in radius units.
		 */
		double distanceTolerance = 2d;

		/**
		 * We process at most nFrames. Make it 0 or negative to have no bounds.
		 */
		int nFrames = 10;

		/**
		 * By how many frames to jymp when we do step-wide time browsing.
		 */
		int stepwiseTimeBrowsing = 5;

		@Override
		public String toString()
		{
			return super.toString() + ": " + "QualityThreshold = " + qualityThreshold + ", DistanceTolerance = " + distanceTolerance + ", nFrames = " + nFrames;
		}
	}

}
